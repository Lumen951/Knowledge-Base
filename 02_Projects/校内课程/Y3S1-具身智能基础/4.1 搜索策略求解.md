---
created: 2025-11-30
tags:
  - 笔记
---


# 📚 **第4章：搜索求解策略 - 复习大纲**

## **模块一：搜索的基本概念与状态空间表示**

- **核心目标**：理解什么是搜索，以及如何把一个实际问题（如八数码、TSP）转化为计算机可理解的“图”或“状态空间”。
    
- **重点内容**：
    
    1. 搜索的定义与基本过程（数据驱动 vs 目的驱动）1111。
        
    2. 盲目搜索 vs 启发式搜索的区别 2。
        
    3. **状态空间表示法（重点）**：四元组 $(S, O, S_0, G)$ 的定义 3。
        
    4. 状态空间的图描述（八数码问题、旅行商问题TSP）4444。
        

## **模块二：盲目图搜索策略 (Blind Search)**

- **核心目标**：掌握不依赖启发信息的“暴力”搜索方法，理解其数据结构和优缺点。
    
- **重点内容**：
    
    1. **回溯策略**：思想、PS表/NPS表/NSS表的作用 5555。
        
    2. **宽度优先搜索 (BFS)**：
        
        - 数据结构：Open表（FIFO队列） 6。
            
        - 特性：完备性、能找到最优解，但空间复杂度高（组合爆炸） 7777。
            
    3. **深度优先搜索 (DFS)**：
        
        - 数据结构：Open表（FILO堆栈） 8。
            
        - 特性：深度限制、容易迷失路径，但节省空间 9999。
            

## **模块三：启发式图搜索策略 (Heuristic Search)**

- **核心目标**：理解如何利用“经验知识”加速搜索，这是迈向智能规划的关键。
    
- **重点内容**：
    
    1. 启发式策略的概念：利用启发信息剪枝（如一字棋、AlphaGo原理） 10101010。
        
    2. **估价函数 (Evaluation Function)**：
        
        - 公式：$f(n) = g(n) + h(n)$ 11。
            
        - $g(n)$ 与 $h(n)$ 的含义及权衡 12。
            

## **模块四：A搜索与`A*`算法 (核心难点)**

- **核心目标**：掌握`A*`算法的原理、流程及其最优性证明（这是考试中最常考的难点）。
- **重点内容**：
    1. **A算法**：基本流程、Open/Closed表的维护与重排 13131313。
    2. **`A*`算法的定义**：$h(n) \le h^*(n)$ (低估条件) 14。
    3. **`A*`算法的特性**：
        - 可采纳性 (Admissibility) 15。
        - 一致性/单调性 (Consistency/Monotonicity) 16。
        - 最优性证明 17。

# 搜索的基本概念与状态空间表示
在人工智能中，当一个问题缺乏直接的计算公式求解时，我们通过“试探”的方式寻找答案，这个过程就是搜索 。
- **核心要素**：
    - **问题的表示**：如果无法描述问题，就无法求解 。
    - **求解方法**：选择合适的策略（如盲目或启发式） 。
- **搜索的四个基本问题**：
    1. 一定能找到解吗？（完备性）
    2. 找到的解是最好的吗？（最优性）
    3. 需要花费多少时间？占用多少内存？（时间/空间复杂度）
    4. 程序会死循环吗？（终止性）

搜索的三种方向：
- **数据驱动（正向搜索）**：从**初始状态**出发，向目标状态探索。这是最符合直觉的方式 。
- **目的驱动（逆向搜索）**：从**目标状态**出发，倒推需要满足的条件。比如证明题常用的“执果索因” 。
- **双向搜索**：同时从起点和终点出发，在中间“会师”。如果路径连通，效率通常更高 。

盲目搜索 vs 启发式搜索
- **盲目搜索 (Blind Search)**：**无信息**搜索。只按固定步骤（如一层层找、一条路走到黑），不考虑问题本身的特性，效率通常较低 。
- **启发式搜索 (Heuristic Search)**：**有信息**搜索。利用特定领域的知识（如“这一步离终点更近”），动态调整搜索顺序，优先选“看起来更有希望”的路径，目的是减少无效搜索 。

## 问题表示

状态空间表示法：将具身智能任务（如机械臂抓取、机器人导航）数学化的关键步骤。
状态空间是一个四元组 $(S, O, S_{0}, G)$ ：
- **$S$ (State)**：状态集合。描述某种状况的一组变量或数组 。
- **$O$ (Operator)**：操作算子集合。描述状态之间如何转移（引起状态变化的函数或规则）。
- **$S_{0}$**：初始状态集合。是 $S$ 的非空子集。
- **$G$ (Goal)**：目的状态集合。可以是具体的状态，也可以是满足某些性质的条件。

黑白棋示例：

|**元素**|**你的描述**|**规范描述（对你回答的补充）**|**具身智能的意义**|
|---|---|---|---|
|**$S$ (状态)**|当前棋子的落子情况|**$S$** 是棋盘上所有格子的一个完整快照，通常用一个 $8 \times 8$ 的数组表示，数组中的每个元素的值为：黑棋（1）、白棋（-1）或空（0）。|**具身环境感知**：机器人的“感官”系统对环境的当前认知。|
|**$O$ (操作)**|下一个落黑子或者白子的位置|**$O$** 是一个合法的**下子动作**：选择棋盘上的一个**空位**，并执行落子，导致至少一颗对方棋子被翻转。|**具身动作执行**：机器人执行一个具体的动作，如移动机械臂、按下开关等。|
|**$S_{0}$ (初始状态)**|(未提及)|棋盘中心固定的两黑两白初始布局。|**任务起始点**：机器人在开始任务时的初始位置和状态。|
|**$G$ (目的状态)**|(未提及)|棋盘上没有合法落子点，或棋子全部落满。通常目标是最大化己方棋子数量（赢）。|**任务完成条件**：机器人成功到达目标位置或完成指定任务。|

## 盲目图搜索策略 (Blind Search)

### 回溯策略
**核心思想**：从初始状态出发，不停地试探寻找路径。如果遇到“死胡同”（不可解结点），就**倒退**（回溯）到最近的父结点，换一条路继续试 。
**三个关键表**（考试可能考名词解释）：
- **PS表 (Path States)**：保存当前搜索路径上的状态 。
- **NPS表 (New Path States)**：保存等待搜索的新状态（未被扩展的）。
- **NSS表 (No Solvable States)**：“死胡同”记录表。如果以后遇到在这个表里的状态，直接跳过，避免重复进死胡同 。

### 宽度优先搜索 (BFS, Breadth-First Search)
**搜索逻辑**：先由初始状态生成第一层所有子状态，检查是否是目标；若不是，再从第一层生成第二层所有子状态...以此类推 。
- **数据结构**：**Open表**是一个**先进先出 (FIFO)** 的**队列**结构 。
- **优点**：
    - **完备性**：只要有解，它一定能找到。
    - **最优性**：一定能找到**路径最短**（步数最少）的解，因为它是按层级由近及远找的 。
- **缺点**：
    - **组合爆炸**：如果分支很多，每一层的节点数会呈指数级增长，消耗大量内存和计算资源，可能导致“内存溢出”而算不出来 。

### 深度优先搜索 (DFS, Depth-First Search)
**搜索逻辑**：总是优先扩展最新生成的子状态，尽可能深地搜索下去 。

- **数据结构**：**Open表**是一个**先进后出 (FILO)** 的**堆栈**结构 。
- **优点**：
    - **节省空间**：不需要像BFS那样保存整整一层的节点，只需要保存当前单一路径上的节点。
    - **速度快**：如果运气好（或者解很深），能比BFS更快找到解 。
- **缺点**：
    - **不一定最优**：找到的第一个解未必是路径最短的 。
    - **容易迷失**：如果没有**深度限制**，可能会陷入无限深的路径（死循环）而找不到解 。


### 启发式图搜索策略 (Heuristic Search)

定义：利用与特定问题相关的**启发信息**（先验知识或经验）来引导搜索过程
**目的**：**剪枝 (Pruning)**。通过判断哪些路径“没希望”，直接把它们剪掉，不再搜索，从而大大缩小搜索空间

估价函数：
$$f(n) = g(n) + h(n)$$
**参数详解**：
- **$g(n)$**：**“已付出的代价”**。从初始节点 $S_0$ 到当前节点 $n$ 的**实际**代价值（比如已经走了多少公里）8。
- **$h(n)$**：**“预估的剩余代价”**。从当前节点 $n$ 到目标节点 $G$ 的**最佳路径估计值**（比如目测还要走多少公里）9。
- **$f(n)$**：**“总估价”**。估计经过节点 $n$ 到达目标的总代价。

### A搜索与`A*`搜索算法 (The `A*` Search Algorithm)

**`A*` 算法是 A 算法的一个特例**。它的核心在于对启发函数 $h(n)$ 加了一个**限制条件**。

条件：
$$h(n) \le h^*(n)$$

只要满足 $h(n) \le h^*(n)$，`A*`算法就具备以下两条神级属性：

1. 可采纳性 (Admissibility)：
    只要问题有解，`A*`算法一定能找到解，而且找到的一定是最优解（路径代价最小）。
2. 一致性/单调性 (Consistency/Monotonicity)：
    这是一个更强的条件。要求 $h(n)$ 的变化符合“三角不等式”，即 $h(n) \le c(n, a, n') + h(n')$ 8。
    - 如果满足一致性，那么 $f(n)$ 的值在搜索路径上是**单调递增**的（不会忽大忽小），搜索效率最高。
    - **结论**：如果 $h(n)$ 是一致的，那它一定是可采纳的（反之不成立）。





